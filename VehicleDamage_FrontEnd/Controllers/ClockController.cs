using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.WindowsAzure.Storage;
using Microsoft.WindowsAzure.Storage.Blob;
using VehicleDamage_FrontEnd.Models;
using VehicleDamage_FrontEnd.Models.Clock;
using VehicleDamage_FrontEnd.Models.DTOs;
using VehicleDamage_FrontEnd.Services.BEService;
using VehicleDamage_FrontEnd.Services.BlobService;
using VehicleDamage_FrontEnd.Services.DamageService;

namespace VehicleDamage_FrontEnd.Controllers
{
    public class ClockController : Controller
    {
        private readonly IDamageService _damageService;
        private readonly IBEService _vehicleService;
        private readonly IBlobService _blobService;

        /// <summary>
        /// Constructor for the controller that sets a context for each of the services.
        /// Which service is passed is controlled by the Enviornment in the startup
        /// </summary>
        /// <seealso cref="Startup"/>
        /// <param name="damService">Either fake or live AI Damage Service</param>
        /// <param name="veService">Either fake or live Back End Service</param>
        /// <param name="blService">Either fake or live blob stroage service</param>
        public ClockController(IDamageService damService, IBEService veService, IBlobService blService)
        {
            _damageService = damService;
            _vehicleService = veService;
            _blobService = blService;
        }

        /// <summary>
        /// Default route for the Clock Vehicle process.
        /// Empty model for the user to enter a Vehicle Liscence Plate.
        /// </summary>
        /// <seealso cref="Models.Clock.ClockModel"/>
        /// <returns>View of the ClockModel</returns>
        public IActionResult ClockVehicle()
        {
            ClockModel newModel = new ClockModel();

            return View(newModel);
        }

        /// <summary>
        /// Handles POST after the user has entered a an lplate number in the ClockVehicle Form.
        /// </summary>
        /// <seealso cref="ClockModel"/>
        /// <param name="model">ClockModel with the liscence plate field filled by the user</param>
        /// <returns>ClockVehicle view with the rest of the vehicle and clock details filled in</returns>
        // POST: Vehicle/Create
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> ClockVehicle(ClockModel model)
        {
            try
            {
                //Check liscence plate belongs to active vehicle
                VehicleDTO dto = await _vehicleService.GetVehicleAsync(model.vehicle.licenceNum);
                //If not found
                if (dto == null)
                {
                    //Reutn error
                    ModelState.AddModelError("vehicle.licenceNum", "Vehicle not found.");
                    return View(model);
                }
                //If there are any currently unresolved damage cases on the vehicle
                else if (dto.state == "Under Investigation")
                {
                    //Return error
                    ModelState.AddModelError("vehicle.licenceNum", "Vehicle currently unavailable due to potential damages. Please contact a member of staff.");
                    return View(model);
                }

                //Create model from the DTO
                ClockModel newModel = ClockModel.CreateModel(dto);
                //Return view with the update model
                return View(newModel);
            }
            catch
            {
                //Redirect tohe main blank page
                return RedirectToAction("ClockVehicle");
            }
        }

        /// <summary>
        /// After user confirms the form generated by the ClockVehicle Post method is correct.
        /// </summary>
        /// <seealso cref="ClockModel"/>
        /// <seealso cref="ClockVehicle(ClockModel)"/>
        /// <seealso cref="ImageDTO"/>
        /// <seealso cref="ImageDTO.GenerateImageId(Guid, string, string, IFormFile)"/>
        /// <param name="cModel">Clcok model with the details of the new state fileld out</param>
        /// <returns></returns>
        [HttpPost]
        [ValidateAntiForgeryToken]
        public async Task<ActionResult> ConfirmClockVehicle(ClockModel cModel)
        {
            //Due to the lack of an auth/identitfy of the driver
            //This would is acting as a placeholder for the current driver ID
            Guid driverID = Guid.NewGuid();

            string updateResponse = null;

            //If clock in, check for damages against the AI service
            if (cModel.clock == "In")
            {
                //Generate a new ID for the potential damage model
                Guid damageID = Guid.NewGuid();

                //Create ImageDTO list for each image to be added as we go through the loop of uploads.
                List<ImageDTO> vehicleImages = new List<ImageDTO>();

                //Set state of tracking = null
                //Used to track the verdict. 
                //This allows to continue processing all uploaded images but still know that one showed damage
                string verdictTracker = "Undamaged";
                //Set counter to 0. This is used to add a suffix count to the end of the image filename when uploaded
                int count = 0;

                //Loop through uploads
                foreach(IFormFile img in cModel.imgs) 
                {
                    //Increment the count
                    count++;
                    //Create a new image DTO. 
                    ImageDTO newImageDTO = ImageDTO.CreateDTO(ImageDTO.GenerateImageId(damageID, cModel.time, count.ToString(), img), img);
                    vehicleImages.Add(newImageDTO);

                    try
                    {
                        //Check the damage of the images against the AI model
                        APIDTO returnApiDto = await _damageService.DamageCheckImg(newImageDTO);

                        //Extract at the decimal percentage of guesses for each tag
                        double damagedGuess = returnApiDto.predictions.FirstOrDefault(x => x.tagName == "Damaged").probability;
                        double wholeGuess = returnApiDto.predictions.FirstOrDefault(x => x.tagName == "Whole").probability;

                        //If both results are over 0.1 then cant say for certain. i.e level of uncertainty
                        //This is to make sure a Staff member will manually resolve it
                        if (wholeGuess >= 0.1 && damagedGuess >= 0.1)
                        {
                            //If not already set to damage from previous image.
                            //Test this because Damaged is a stronger case than Inclonclusive
                            if(verdictTracker == "Undamaged") 
                            {
                                verdictTracker = "Inconclusive";
                            }
                        }
                        //If the verdict is Damaged
                        else if (damagedGuess > wholeGuess)
                        {
                            //If Damaged then overrules the above conclusion of a previous image
                                verdictTracker = "Damaged";                          
                        }
                    }
                    catch 
                    {
                        //In any case of an error, set to Inclousive
                        verdictTracker = "Inconclusive";
                    }
                }

                //After loop of images, check the state.
                //If either damage or incloncsive
                if (verdictTracker != "Undamaged") 
                {
                    try 
                    { 
                        //Set the new state to
                        if (verdictTracker == "Inconclusive") 
                        {
                            cModel.clock = "Inconclusive";
                        }
                        //Damaged
                        else 
                        {
                            cModel.clock = "Damaged";
                        }

                        //Create and Insert a Damage history record to keep track of vehicle damages
                        DamageHistoryDTO newDamageDTO = DamageHistoryDTO.CreateDTO(DamageHistoryModel.CreateModel(cModel, damageID, driverID));
                         updateResponse = await _vehicleService.InsertDamageHistoryAsync(newDamageDTO);
                        if (updateResponse != "Success")
                        {
                            return RedirectToAction("ClockVehicle");
                        }

                        //Update Vehicle with new state
                        cModel.vehicle.state = "Under Investigation";
                        VehicleDTO newVehDto = VehicleDTO.CreateDTO(cModel.vehicle);
                        updateResponse = await _vehicleService.UpdateVehicleAsync(newVehDto);
                        if (updateResponse != "Success")
                        {
                            return RedirectToAction("ClockVehicle");
                        }

                        //Loop and upload images to blob storage
                        foreach(ImageDTO img in vehicleImages) 
                        {
                            //Save Images to the blob storage.
                            updateResponse = await _blobService.UploadImage(img);
                            if (updateResponse != "Success")
                            {
                                return RedirectToAction("ClockVehicle");
                            }
                        }

                        //Return back to confirmed view
                        return View("ClockConfirmed", cModel);

                    }
                    catch 
                    {
                        //if error at anypoint, restart the form by rdirecting to initial action
                        return RedirectToAction("ClockVehicle");
                    }                                 
                }
            }

            //Update state of the vehicle in vehicle table
            cModel.vehicle.state = cModel.clock;
            VehicleDTO vehDTO = VehicleDTO.CreateDTO(cModel.vehicle);
            updateResponse = await _vehicleService.UpdateVehicleAsync(vehDTO);
            if (updateResponse != "Success")
            {
                return RedirectToAction("ClockVehicle");
            }

            //Insert into the history table.      
            //Note: The DriverID would be replaced with identification if implemented as mentioned above
            Guid historyID = Guid.NewGuid();
            ClockHistoryDTO newDTO = ClockHistoryDTO.CreateDTO(cModel, historyID, driverID);
            updateResponse = await _vehicleService.InsertClockHistoryAsync(newDTO);
            if (updateResponse != "Success")
            {
                return RedirectToAction("ClockVehicle");
            }

            //Return back to confirmed view
            return View("ClockConfirmed", cModel);
        }
    }
}